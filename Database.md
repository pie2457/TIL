# Database
<br>

### 📌 트랜잭션

<details>
   <summary> 답안 </summary>
<br />

- 트랜잭션이란 데이터베이스 내의 최소 작업단위입니다. 트랜잭션은 ACID의 성질을 가지고 있으며, 이는 각 원자성, 일관성, 독립성, 지속성을 의미합니다. <br>
  - 원자성(Atomicity) : 트랜잭션에 포함된 작업은 모두 수행되거나 모두 수행되지 않아야 하는 성질을 의미합니다.
  - 일관성(Consistency) : 트랜잭션을 수행하기 전이나 후나 데이터베이스는 항상 일관된 상태를 유지하는 성질을 의미합니다.
  - 독립성(Isolation) : 트랜잭션이 시작되면 다른 어떠한 작업도 끼어들 수 없다는 것을 의미합니다.
  - 지속성(Durability) : 수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 한다는 것을 의미합니다.

</details>
<br>

### 📌 트랜잭션 격리수준
<details>
   <summary> 답안 </summary>
<br />

- 트랜잭션 격리 수준(Isonlation Level)이란 **여러 트랜잭션이 동시에 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지
  여부를 결정하는 것입니다**. 트랜잭션의 격리 수준은 격리(고립) 수준이 높은 순서대로 `SERIALIZABLE`, `REPEATABLE READ`, `READ COMMITTED`, `READ UNCOMMITTED`가 존재합니다.
  - **[SERIALIZABLE]**
    - SERIALIZABLE은 이름 그대로 트랜잭션을 순차적으로 진행시킵니다. **여러 트랜잭션이 동일한 레코드에 동시에 접근할 수 없으므로**, 데이터 부정합 문제도 발생하지 않습니다.
      하지만 **트랜잭션이 순차적으로 처리되어야 하므로 동시 처리 성능이 매우 떨어집니다**. SERIALIZABLE은 가장 안전하지만, 가장 성능이 떨어지므로 극단적으로 안전한 작업이 필요한
      경우가 아니라면 사용하지 않는 것이 좋습니다.
  - **[REPEATABLE READ]**
    - REPEATABLE READ는 MySQL의 InnoDB에서 기본으로 사용하는 트랜잭션 격리 수준입니다. REPEATABLE READ는 **MVCC를 이용해 한 트랜잭션 내에서 동일한 결과를 보장하지만, 
      새로운 레코드가 추가되는 경우에 부정합이 생길 수 있습니다**. 이러한 부정합을 방지하기 위해 InnoDB는 갭락과 넥스트 키락을 활용합니다. 
  - **[READ COMMITTED]**
     - READ COMMITTED는 **커밋된 데이터만을 조회할 수 있는 격리 수준**입니다. 특정 트랜잭션에서 데이터가 변경되었으나, 아직 커밋되지 않은 상태라면 다른 트랜잭션에서는
       해당 데이터를 읽을 수 없고 커밋이 된 이후에야 변경된 데이터 값을 읽을 수 있습니다. 이러한 특성으로 **Phantom Read의 문제와 Non-Repeatable Read 문제가 발생할 수 있습니다**.
  - **[READ UNCOMMITTED]**
     - READ UNCOMMITTED는 **커밋되지 않은 데이터 조차도 접근할 수 있는 격리 수준**입니다. **데이터의 부정합 문제가 발생할 확률이 높지만, 성능은 가장 빠르다는 특징**이 있습니다.
       하여 데이터를 어림잡아 집계하는 등의 연산에 유용하게 사용됩니다.
</details>
<br>

### 📌 Commit & Rollback
<details>
   <summary> 답안 </summary>
<br />

- commit이란 한 트랜잭션 내의 모든 작업을 데이터베이스에 반영하는 작업이며, rollback이란 작업 중 문제가 발생되어
  트랜잭션의 처리과정에서 발생한 변경사항을 취소하는 명령어 입니다. 


</details>
<br>

### 📌 동시성 제어 기법 / 2PL
<details>
   <summary> 답안 </summary>
<br />

- 2-Phase-Lock(2단계 잠금 프로토콜)이란 트랜잭션 도중에 락을 걸어 동일한 데이터에 동시에 접근하려는 트랜잭션을 차단하여 직렬화를 보장하는 DBMS의 동시 제어 방법입니다.<br>
![image](https://github.com/pie2457/backend_tech_interview/assets/104147789/0b1df445-b8f6-4db7-a985-7d99edaed29c) <br>
  2PL은 각 트랜잭션이 두 단계로 락 획득 또는 해제 요청을 할 수 있습니다. <br>
  - Growing Phase : 이 단계에서는 오직 잠금을 획득할 수 있고, 해제할 수는 없습니다.
  - Shrinking Phase : 이 단계에서는 트랜잭션이 잠금을 해제할 수는 있지만, 새로운 잠금을 획득할 수는 없습니다.


</details>
<br>

### 📌 동시성 제어 기법 / Pessimistic Lock & Optimistic Lock
<details>
   <summary> 답안 </summary>
<br />

- [Pessimistic Lock]
   - 비관적 락은 2개 이상의 트랜잭션이 동시에 동일한 데이터에 접근할 것이라 가정하여 DB의 실제 데이터에 락을 걸어 데이터의 정합성을 맞추는 방식입니다. 비관적 락은 트랜잭션이 시작할 때 X-Lock 또는 S-Lock을 걸게 됩니다.
      - 배타 락 (Exclusive-Lock, X-Lock) : 배타 락은 엔티티에 접근하려는 모든 요청을 제어합니다. 하나의 요청이 자원을 얻으면 다른 요청은 대기 상태가 됩니다.
      - 공유 락 (Shared-Lock, S-Lock) : 공유 락은 업데이트 상황에서만 동시성 제어를 하고 있습니다. 조회만 하는 경우에는 락이 발생하지 않고 접근이 가능합니다.
- [Optimisitic Lock]
   - 낙관적 락은 2개 이상의 트랜잭션이 동시에 동일한 데이터에 접근하지 않을 것이라 가정하여 실제로 락을 사용하지는 않고 버전 정보를 이용해 데이터의 정합성을 맞추는 방식입니다.
     같은 데이터에 동시에 접근할 때와 데이터를 변경하려 할 때 버전 정보가 다르다면 rollback이 일어납니다.

</details>
<br>
